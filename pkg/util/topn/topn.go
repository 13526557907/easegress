package topn

import (
	"sort"
	"sync"
	"sync/atomic"

	"github.com/megaease/easegateway/pkg/context"
	"github.com/megaease/easegateway/pkg/util/httpstat"
	"github.com/megaease/easegateway/pkg/util/urlclusteranalyzer"
)

const (
	maxN = 500
)

type (
	// TopN is the statistics tool for HTTP traffic.
	TopN struct {
		n int

		m    sync.Map // map[string]*httpstat.HTTPStat
		mlen uint64

		uca *urlclusteranalyzer.URLClusterAnalyzer
	}

	// Item is the item of status.
	Item struct {
		Path string `yaml:"path"`
		*httpstat.Status
	}

	// Status contains all status generated by TopN.
	Status []*Item
)

func (s Status) Len() int           { return len(s) }
func (s Status) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }
func (s Status) Less(i, j int) bool { return s[i].Status.Count > s[j].Status.Count }

// New creates a TopN.
func New(n int) *TopN {
	return &TopN{
		n:   n,
		uca: urlclusteranalyzer.New(),
	}
}

// Stat stats the ctx.
func (t *TopN) Stat(ctx context.HTTPContext) {
	if atomic.LoadUint64(&t.mlen) >= maxN {
		return
	}

	pattern := t.uca.GetPattern(ctx.Request().Path())

	// NOTE: Not use LoadOrStore in the first time
	// for reducing massive construction of HTTPStat.
	httpStat, exists := t.m.Load(pattern)
	if !exists {
		httpStat = httpstat.New()
		var loaded bool
		httpStat, loaded = t.m.LoadOrStore(pattern, httpStat)
		if !loaded {
			atomic.AddUint64(&t.mlen, 1)
		}
	}
	httpStat.(*httpstat.HTTPStat).Stat(ctx)
}

// Status returns TopN Status.
func (t *TopN) Status() *Status {
	status := make(Status, 0)
	t.m.Range(func(key, value interface{}) bool {
		pattern := key.(string)
		httpStat := value.(*httpstat.HTTPStat)

		status = append(status, &Item{
			Path:   pattern,
			Status: httpStat.Status(),
		})
		return true
	})

	sort.Sort(status)
	n := len(status)
	if n > t.n {
		n = t.n
	}

	topNStatus := status[0:n]

	return &topNStatus
}
